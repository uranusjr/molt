# The Lock File

See contents of `molt.lock.schema.json` for a complete JSON Schema definition
of the file.

## File format and name

The file name must ends in `.lock.json`. The extension is chosen to be both
semantically readable, and easy to identify for a tool (such as an editor to
correctly apply syntax highlighting).

The format is JSON. A tool generating the lock file should normalize the output
to make it human-readable and easy to edit. If using Python, the preferred
configuration to output (using the built-in `json` module) is:

```python
json.dumps(
    data,
    ensure_ascii=True,
    indent=4,
    separators=(',', ': '),
    sort_keys=True,
)
```

## Top-level fields

There are three top-level fields:

* *dependencies* contains a mapping of packages that are depended on.
* *sections* contains a mapping of dependency sections. Each section specifies
  a set of dependencies that can be installed together.
* *sources* specifies places to find packages. Each dependency may specify
  one or more specific sources to fetch artifacts from, or leave this for the
  tool to decide.
* *hashes* is a mapping of hashes used to check the integrity of downloaded
  packages.

Implementers can store their tool-specific data in top-level fields prefixed
with an underscore (`_`). To avoid conflicts, each tool should only use one
top-level field named after the tool. For example, Molt stores its data in a
top-level field named `_molt`.


## `dependencies`

## `sections`

## `sources`

## `hashes`


## Discussions

### File format

The JSON format is chosen because it is ubiquitous across platforms and
languages. It is more difficult to generate by hand, but this is not as
important since it is very unlikely to be the case. It is also possible to
edit the tool-generated output, since it is formatted.

TOML is considered, but ultimately rejected since the output is too volitile.
The same data structure can generate many equivalent TOML outputs, and it makes
interoperability more difficult. Lock files generated by different tools would
potentially have very different contents, even if the underlying structure is
similar, even identical. Normalized JSON makes it easier for a human to
understand how much has changed by simply inspecting diff.
