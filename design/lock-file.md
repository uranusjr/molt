# The Lock File

See contents of `molt.lock.schema.json` for a complete JSON Schema definition
of the file.

## Design

### File format and name

The file name must ends in `.lock.json`. The extension is chosen to be both
semantically readable, and easy to identify for a tool (such as an editor to
correctly apply syntax highlighting).

The format is JSON. A tool generating the lock file should normalize the output
to make it human-readable and easy to edit. If using Python, the preferred
configuration to output (using the built-in `json` module) is:

```python
import json

json.dumps(
    ...,
    ensure_ascii=True,
    indent=4,
    separators=(',', ': '),
    sort_keys=True,
)
```

### Top-level fields

There are three top-level fields:

* *dependencies* contains a mapping of dependencies to use. A dependency may
  be a real package, or a “virtual” dependency that describes a set of
  dependencies.
* *sources* specifies places to find packages. Each dependency may specify
  one or more specific sources to fetch artifacts from, or leave this for the
  tool to decide.
* *hashes* is a mapping of hashes used to check the integrity of downloaded
  packages.

Implementers can store their tool-specific data in top-level fields prefixed
with an underscore (`_`). To avoid conflicts, each tool should only use one
top-level field named after the tool. For example, Molt stores its data in a
top-level field named `_molt`.

#### `sources`

TODO

#### `dependencies`

This section describes a direction graph that represents the dependency tree.
Each key in the mapping uniquely identifies a node in the graph.[1]

[1]: The identifier does *not* represent the name of a Python package, although
     it it totally reasonable to do so. See below if you’re interested in how
     Molt decides what keys to use.

Each dependency entry may contain one or both of the following keys:

* *dependencies* is an object to list other dependency entries this one depends
  on. Each key should be a key in the top-level *dependencies* object. The
  value should be a list of markers, meaning that the dependency should be
  activated if any of the markers evaluate to true. Specify `null` to activate
  the dependency unconditionally.
* *python*, if specified, is an object specifying a concrete package to
  install. This object must contain two keys, *name* and *version*, to specify
  the package. An optional key *sources* list one of more sources to find the
  package from. The “default” source should be used if *sources* is left out.

(The *python* key should specify a package on a Python package index, such as
PyPI. This may be extended in the future to include other package sources like
Conda.)


#### `hashes`

TODO

### Discussions

#### File format

The JSON format is chosen because it is ubiquitous across platforms and
languages. It is more difficult to generate by hand, but this is not as
important since it is very unlikely to be the case. It is also possible to
edit the tool-generated output, since it is formatted.

TOML is considered, but ultimately rejected since the output is too volitile.
The same data structure can generate many equivalent TOML outputs, and it makes
interoperability more difficult. Lock files generated by different tools would
potentially have very different contents, even if the underlying structure is
similar, even identical. Normalized JSON makes it easier for a human to
understand how much has changed by simply inspecting diff.

## How Molt specifies Python packages

(Note: For brevity, examples given in this section only show partial content,
and do not use the recommended format.)

While this lock file design does not specify how dependency keys are specified,
Molt uses a rule similar to [PEP 508].

[PEP 508]: https://www.python.org/dev/peps/pep-0508/

For a straightforward Python package dependency, the key is the (canonical)
package name, e.g.

```json
{
    "django": {
        "python": {"name": "Django", "version": "2.2.0"},
        "dependencies": {"pytz": null, "sqlparse": null}
    }
}
```

For a Python package extra, the key is the package name plus extra, e.g.

```json
{
    "requests[socks]": {
        "dependencies": {"requests": null, "pysocks": null}
    },
    "requests": {
        "python": {"name": "requests", "version": "2.21.0"},
        "dependencies": {
            "certifi": null,
            "chardet": null,
            "idna": null,
            "urllib3": null
        }
    }
}
```

Note that the extra-ed entry does not contain the Requests package itself, but
references an extra-less entry. This enabled the dependency tree to be
unambigiously reconstructed from the lock information.

If a package needs different versions in different environments (e.g. operating
system), a marker is attached to dinstinguish different entries. Personally, I
think it is a terrible idea to have such a dependency tree, but people seems to
expect this feature, and it fits well in the design anyway, so :shrug:

```json
{
    "pyarrow": {
        "dependencies": {
            "pyarrow;sys_platform=='darwin'": ["sys_platform == 'darwin'"],
            "pyarrow;sys_platform!='darwin'": ["sys_platform != 'darwin'"]
        }
    },
    "pyarrow;sys_platform=='darwin'": {
        "python": {"name": "pyarrow", "version": "0.9.0.post1"},
        "dependencies": {"numpy": null, "six": null}
    },
    "pyarrow;sys_platform!='darwin'": {
        "python": {"name": "pyarrow", "version": "0.9.0"},
        "dependencies": {"numpy": null, "six": null}
    }
}
```

An empty key is treated specially to indicate the “top-level” dependencies.
This is useful when you’re developing a Python project without a package name,
e.g. a Django website. This can have extras as well, to supply situational
dependencies like dev-only, CI-only, documentation tools, etc.

```json
{
    "": {"dependencies": {"django": null}},
    "[doc]": {"dependencies": {"sphinx": null}},
    "[test]": {"dependencies": {"": null, "pytest-django": null}},
    "[dev]": {"dependencies": {"[test]": null, "django-debug-toolbar": null}}
}
```

This would

* Install Django and its dependencies when you run `molt install`.
* Install Sphinx and its dependencies (but not Django!) on `molt install doc`.
* Install Django, pytest-django, Sphinx, and their dependencies on
  `molt install doc test`.
* Install Django, pytest-django, django-debug-toolbar, and their dependencies
  on `molt install dev`.

and so on.
